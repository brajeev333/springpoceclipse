package com.hcl.demo.util;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;

import com.hcl.demo.dataobject.BaseBO;
import com.hcl.demo.dataobject.Range;

/*************************************************************************
 *
 * HCL CONFIDENTIAL
 * _________________________________________________________________________________
 *
 * HCL is a trademark of HCL Company.
 *
 * Copyright © 2020 HCL. All rights reserved.
 *
 * NOTICE: All information contained herein is, and remains the property of HCL
 * and its suppliers, if any. The intellectual and technical concepts contained
 * herein are proprietary to HCL and its suppliers and may be covered by U.S.
 * and Foreign Patents, patents in process, and are protected by trade secret or
 * copyright law. Dissemination of this information or reproduction of this
 * material is strictly forbidden unless prior written permission is obtained
 * from HCL.
 *
 *************************************************************************/
// Author : Generated by ATMA ®
// Revision History :
public  class DemoUtils {

    public static boolean isNumeric(String input) {
        if (input == null) {
            return false;
        }
        if(input!=null && input.length()>0) {
            if(input.substring(0, 1).equals("+") || input.substring(0, 1).equals("-")) {
                return StringUtils.isNumeric(input.substring(1));
            }
        }
        return StringUtils.isNumeric(input);
    }

    private static boolean valueEquals(Comparable input, List<Comparable> adhocVals) {
        for (Comparable value : adhocVals) {
            if (input.equals(value)) {
                return true;
            }
        }
        return false;
    }

    public static String rightPad(String input, int targetLength) {
        return StringUtils.rightPad((input == null) ? "" : input, targetLength);
    }

    public static Integer parseToInt(String inputString) {
        Integer output = 0;
        if (inputString != null) {
            inputString = inputString.trim();
            if (!inputString.isEmpty()) {
                if (!DemoUtils.isNumeric(inputString)) {
                    throw new UnsupportedOperationException("Input String cannot be treated as number! " + inputString);
                }
                output = Integer.parseInt(inputString);
            }
        }
        return output;
    }

    public static BigDecimal parseToBigDecimal(String inputString) {
        BigDecimal output = BigDecimal.ZERO;
        if (inputString != null) {
            inputString = inputString.trim();
            if (!inputString.isEmpty()) {
                if (!isNumeric(inputString)) {
                    throw new UnsupportedOperationException("Input String cannot be treated as number! " + inputString);
                }
                output = new BigDecimal(inputString);
            }
        }
        return output;
    }

    public static Number readFieldAsNumber(String fieldAsString, String decimalFormatPattern, Class numberClass) throws NumberFormatException {
        char lastCharacter = fieldAsString.charAt(fieldAsString.length() - 1);

        switch (lastCharacter) {
        case '{':
            fieldAsString = StringUtils.overlay(fieldAsString, "0", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'A':
            fieldAsString = StringUtils.overlay(fieldAsString, "1", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'B':
            fieldAsString = StringUtils.overlay(fieldAsString, "2", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'C':
            fieldAsString = StringUtils.overlay(fieldAsString, "3", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'D':
            fieldAsString = StringUtils.overlay(fieldAsString, "4", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'E':
            fieldAsString = StringUtils.overlay(fieldAsString, "5", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'F':
            fieldAsString = StringUtils.overlay(fieldAsString, "6", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'G':
            fieldAsString = StringUtils.overlay(fieldAsString, "7", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'H':
            fieldAsString = StringUtils.overlay(fieldAsString, "8", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'I':
            fieldAsString = StringUtils.overlay(fieldAsString, "9", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case '}':
            fieldAsString = "-" + StringUtils.overlay(fieldAsString, "0", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'J':
            fieldAsString = "-" + StringUtils.overlay(fieldAsString, "1", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'K':
            fieldAsString = "-" + StringUtils.overlay(fieldAsString, "2", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'L':
            fieldAsString = "-" + StringUtils.overlay(fieldAsString, "3", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'M':
            fieldAsString = "-" + StringUtils.overlay(fieldAsString, "4", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'N':
            fieldAsString = "-" + StringUtils.overlay(fieldAsString, "5", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'O':
            fieldAsString = "-" + StringUtils.overlay(fieldAsString, "6", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'P':
            fieldAsString = "-" + StringUtils.overlay(fieldAsString, "7", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'Q':
            fieldAsString = "-" + StringUtils.overlay(fieldAsString, "8", fieldAsString.length() - 1, fieldAsString.length());
            break;
        case 'R':
            fieldAsString = "-" + StringUtils.overlay(fieldAsString, "9", fieldAsString.length() - 1, fieldAsString.length());
            break;
        default:
            break;
        }

        int indexOfDecimalPoint = decimalFormatPattern.indexOf('.');
        indexOfDecimalPoint = (numberClass.equals(Integer.class) || numberClass.equals(BigInteger.class)) ? -1 : indexOfDecimalPoint;// Ignore index if a whole number is being asked for
        boolean isWholeNumber = (indexOfDecimalPoint < 0);

        if (!isWholeNumber) {
            fieldAsString = fieldAsString.substring(0, indexOfDecimalPoint) + '.' + fieldAsString.substring(indexOfDecimalPoint);
        }

        if (numberClass.equals(Integer.class)) {
            return (Number) Integer.parseInt(fieldAsString);
        }

        if (numberClass.equals(Long.class)) {
            return (Number) Long.parseLong(fieldAsString);
        }

        if (numberClass.equals(Float.class)) {
            return (Number) Float.parseFloat(fieldAsString);
        }

        if (numberClass.equals(Double.class)) {
            return (Number) Double.parseDouble(fieldAsString);
        }

        if (numberClass.equals(BigInteger.class)) {
            return (Number) (new BigInteger(fieldAsString));
        }

        if (numberClass.equals(BigDecimal.class)) {
            return (Number) (new BigDecimal(fieldAsString));
        }

        return 0;
    }

    private static boolean isNegative(Number number) {
        boolean isNegative = false;

        if (number instanceof Integer) {
            if (((Integer) number).intValue() < 0) {
                isNegative = true;
            }
        } else if (number instanceof BigInteger) {
            if (((BigInteger) number).compareTo(BigInteger.ZERO) == -1) {
                isNegative = true;
            }
        } else if (number instanceof Long) {
            if (((Long) number).longValue() < 0) {
                isNegative = true;
            }
        } else if (number instanceof Float) {
            if (((Float) number).floatValue() < 0) {
                isNegative = true;
            }
        } else if (number instanceof Double) {
            if (((Double) number).doubleValue() < 0) {
                isNegative = true;
            }
        } else if (number instanceof BigDecimal) {
            if (((BigDecimal) number).compareTo(BigDecimal.ZERO) == -1) {
                isNegative = true;
            }
        }

        return isNegative;
    }

    /**
     * Format number as String
     *
     * @param number
     *            input
     * @param decimalFormatPattern
     *            if null, returns with the default format.
     * @return String representation of number
     */
    public static String readNumberAsString(Number number, String decimalFormatPattern) {
        boolean isPositive = !isNegative(number);
        StringBuilder numberAsString = null;
        if (decimalFormatPattern == null) {
            if (number instanceof Integer || number instanceof Float) {
                numberAsString = new StringBuilder(number.toString());
            } else if (number instanceof Long) {
                numberAsString = new StringBuilder(((Long) number).toString());
            } else if (number instanceof Double) {
                numberAsString = new StringBuilder(new BigDecimal((Double) number).toPlainString());
            } else if (number instanceof BigInteger) {
                numberAsString = new StringBuilder(new BigDecimal((BigInteger) number).toPlainString());
            } else if (number instanceof BigDecimal) {
                numberAsString = new StringBuilder(((BigDecimal) number).toPlainString());
            }
        } else {
            DecimalFormat decimalFormat = new DecimalFormat(decimalFormatPattern);
            numberAsString = new StringBuilder(decimalFormat.format(number));
        }

        int indexOfDecimalPoint = numberAsString.indexOf(".");
        if (indexOfDecimalPoint > -1) {
            numberAsString.deleteCharAt(indexOfDecimalPoint);
        }
        char lastChar = numberAsString.charAt(numberAsString.length() - 1);
        switch (lastChar) {
        case '0':
            numberAsString.setCharAt(numberAsString.length() - 1, isPositive ? '{' : '}');
            break;
        case '1':
            numberAsString.setCharAt(numberAsString.length() - 1, isPositive ? 'A' : 'J');
            break;
        case '2':
            numberAsString.setCharAt(numberAsString.length() - 1, isPositive ? 'B' : 'K');
            break;
        case '3':
            numberAsString.setCharAt(numberAsString.length() - 1, isPositive ? 'C' : 'L');
            break;
        case '4':
            numberAsString.setCharAt(numberAsString.length() - 1, isPositive ? 'D' : 'M');
            break;
        case '5':
            numberAsString.setCharAt(numberAsString.length() - 1, isPositive ? 'E' : 'N');
            break;
        case '6':
            numberAsString.setCharAt(numberAsString.length() - 1, isPositive ? 'F' : 'O');
            break;
        case '7':
            numberAsString.setCharAt(numberAsString.length() - 1, isPositive ? 'G' : 'P');
            break;
        case '8':
            numberAsString.setCharAt(numberAsString.length() - 1, isPositive ? 'H' : 'Q');
            break;
        case '9':
            numberAsString.setCharAt(numberAsString.length() - 1, isPositive ? 'I' : 'R');
            break;
        }
        return isPositive ? numberAsString.toString() : numberAsString.substring(1);
    }

    public static boolean checkIfWritable(String filePath) {
        return Files.isWritable(FileSystems.getDefault().getPath(filePath));
    }

    public static String joinStrings(List<String> listOfStrings) {
        return StringUtils.join(listOfStrings);
    }

    public static String joinBos(List<BaseBO> listOfBaseBos) {
        List<String> listOfStrings = new ArrayList<String>(listOfBaseBos.size());
        listOfBaseBos.stream().forEach(bo -> listOfStrings.add(bo.toString()));
        return joinStrings(listOfStrings);
    }

    public static List<String> splitStringToList(String input, int occursCount, int individualItemLength) {
        List<String> output = new ArrayList<String>(occursCount);
        int totalLength = occursCount * individualItemLength;
        input = StringUtils.rightPad(input, totalLength, ' ');
        for (int index = 0; index < occursCount; index++) {
            output.add(input.substring(index * individualItemLength, (index + 1) * individualItemLength));
        }
        return output;
    }

    public static String hexToAscii(String hexStr) {
        StringBuilder output = new StringBuilder();

        for (int i = 0; i < hexStr.length(); i += 2) {
            String str = hexStr.substring(i, i + 2);
            output.append((char) Integer.parseInt(str, 16));
        }

        return output.toString();
    }	public static boolean rangeCheck(Comparable input, List<Range> rangeList, List<Comparable> adhocVals) {
        if (input == null) {
            return false;
        }
        boolean check;
        for (Range range : rangeList) {
            if(input instanceof String) {
                if(((String) input).length()>((String)range.getMaxValue()).length()) {
                    if(!valueEquals(input, adhocVals)) {
                        continue;
                    } else {
                        return true;
                    }
                }
            }
            check = input.compareTo(range.getMinValue()) >= 0 && input.compareTo(range.getMaxValue()) <= 0;
            if (check) {
                return check;
            }
        }
        return valueEquals(input, adhocVals);
    }
}